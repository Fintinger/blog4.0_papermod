<!DOCTYPE html>
<html lang="en" dir=" auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>排序算法相关 | Archai&#39;s home</title>
<meta name="keywords" content="数据结构, 冒泡排序, 选择排序, 插入排序, 快速排序, 归并排序, 计数排序, 希尔排序, 堆排序" />
<meta name="description" content="排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1.">
<meta name="author" content="Archai">
<link rel="canonical" href="https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c70fe7a765b250c57b69e8dccf90fd37034279a0e9a06e7607fb22a05b0f5589.css" integrity="sha256-xw/np2WyUMV7aejcz5D9NwNCeaDpoG52B/sioFsPVYk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.fintinger.site/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.fintinger.site/images/favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.fintinger.site/images/favicon.ico">
<link rel="apple-touch-icon" href="https://www.fintinger.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.fintinger.site/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="排序算法相关" />
<meta property="og:description" content="排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-10T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-06-10T00:00:00&#43;00:00" /><meta property="og:site_name" content="Archai&#39;s home" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排序算法相关"/>
<meta name="twitter:description" content="排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.fintinger.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "排序算法相关",
      "item": "https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "排序算法相关",
  "name": "排序算法相关",
  "description": "排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n+rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1.",
  "keywords": [
    "数据结构", "冒泡排序", "选择排序", "插入排序", "快速排序", "归并排序", "计数排序", "希尔排序", "堆排序"
  ],
  "articleBody": "   排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n+rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1.评价指标 时间复杂度，空间复杂度，算法的稳定性\n2.分类 插入排序 1.算法思想 每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成。\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11  //递增排序 void InsertSort(int A[],int n){//长度为n的int型数组  int i,j,temp; for (i = 1; i  n; i++) if (A[i]  A[i-1]) {//如果A[i]的小于其前驱则进行A[i]的移动  temp=A[i];//临时保存A[i]  for (j = i-1; j=0 \u0026\u0026 A[j]temp; j--)//依次检查A[i]之前已经排好序的元素  A[j+1]=A[j];//大于temp的后移  A[j+1]=temp;//最终复制到插入位置  } }   3.优化思路 折半插入排序——先用折半查找找到应该插入的位置，再进行移动元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void InsertSort(int A[],int n){ int i,j,low,high,mid; for (i = 2; i  n; i++) { A[0]=A[i]; low=1,high=i-1;//折半查找的范围  while (lowhigh) { mid=(low+high)/2; if (A[midA[0]]) high=mid-1;//查找左部分  else low=mid+1;//查找右部分  } for (j = i-1; j=high+1; j--)//i之前元素全部后移  A[j+1]=A[j]; A[high+1]=A[0];//插入  } }   注意： 一直到lowhigh时才停止折半查找当mid所指元素等于当前元素时，应继续令low=mid+1，以保证“稳定性“。最终应将当前元素插入到low所指位置（即high+1）\n希尔排序 1.算法思想 先将待排序表分割成若干形如 {i,i+d,i+2d, … , i+kd} 的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d(建议缩小一半)，重复上述过程，直到d=1为止。\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11  void ShellSort(int A[],int n){ int i,j,d; for (d = n/2; d = 1; d=d/2) //步长不断衰减  for ( i = d+1; i  n; i++) //遍历各步长为d的子表,从子表第二个元素开始处理即可  if(A[i]A[i-d]){//如果发现逆序  A[0]=A[i];//暂存需要交换位置的A[i]  for ( j = i-d; j  0 \u0026\u0026 A[0]A[j]; j-=d) //当子表中存在元素，判断与A[i]大小，寻找A[i]插入位置  A[j+d]=A[j];//子表记录后移  A[j+d]=A[0];//插入  }//if }   冒泡排序 1.算法思想 从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]A[i]），则交换它们，直到整个序列比较完毕。\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void swap(int \u0026a,int \u0026b){ int temp=a; a=b; b=temp; } void BubbleSort(int A[],int n){ for (int i = 0; i  n; i++){ //i之前的所有元素必然已经有序  bool flag=false; for (int j = n-1; j  i; j--) //从后往前的一趟冒泡  if (A[j-1]  A[j]) {//逆序,(相等不会交换，是稳定的)  swap(A[j-1],A[j]); flag=true; }//if  if (!flag) { return;//本趟遍历flag未改变，说明已经有序,可能会提前结束  } }//for }   快速排序 1.算法思想 在待排序表L[1…n]中任取一个元素 pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则 pivot放在了其最终位置L[k]上这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void QuickSort(int A[],int low,int high) {//快速排序  if (lowhigh) {//递归跳出的条件  int pivotpos=Partition(A,low,high);//进行“划分”  QuickSort(A,low,pivotpos-1);//处理左子表  QuickSort(A,pivotpos+1,high);//处理右子表  } } int Partition(int A[],int low,int high){//\"划分\"函数，返回 枢轴 位置  int pivot=A[low];//取low作为枢轴  while (lowhigh) {//用low,high搜寻枢轴位置  while (lowhigh \u0026\u0026 A[high]pivot) high--; A[low]=A[high];//比枢轴小的元素移动到左端  while (lowhigh \u0026\u0026 A[low]pivot) low++; A[high]=A[low];//比枢轴大的元素移动到右端  } A[low]=pivot;//改变枢轴low位置  return low; }   3.优化思路 枢轴的选择会直接影响快速排序算法的效率，因此优化应该从枢轴的选择角度考虑。\n① 选择首、中、尾三个位置的元素，取其中中间值作为枢轴元素。\n② 随机选一个作为枢轴……\n4.注意  “一次划分” 与 “一趟排序”\n 一次划分可以确定一个元素的最终位置 一趟排序也许可以确定多个元素的最终位置   简单选择排序 1.算法思想 每一趟在待排序元素中选取关键字最小的元素加入有序子序列\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14  void swap(int \u0026a,int \u0026b){ int temp=a; a=b; b=temp; } void SelectSort(int A[],int n) { for (int i = 0; i  n-1; i++) {//从头开始遍历，最后一个元素无需处理(最终一定是最大)  int min=i;//初始最小元素位置  for (int j = i+1; j  n; j++) //在i之后所有元素中寻找最小元素位置  if (A[j]A[min]) min=j;//更新最小元素位置  if (min!=i) swap(A[min],A[i]);//将最小元素置于表头  } }   堆排序☆ 堆这种数据结构可以类比完全二叉树二叉树结构的顺序存储\n1.建立大根堆 核心特性： 根≥左，右\n思路 把所有非终端结点($i \\leq \\left \\lfloor n/2 \\right \\rfloor$)都检查一遍，是否满足大根堆的要求。\n检查当前结点是否满足 根≥左、右，若不满足，将当前结点与更大的一个孩子互换。\n若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void BuildMaxHeap(int A[],int len){ for (int i = len/2; i  0; i--)//从编号最大非终端节点开始  HeadAdjust(A,i,len); } //调整以k为根节点的树为大根堆 void HeadAdjust(int A[],int k,int len){ A[0]=A[k]; //寻找A[k]应该插入的位置--“下坠”  for (int i = 2*k; i  len; i*=2) { if (ilen\u0026\u0026A[i]A[i+1]) //找到key更大的子结点的下标  i++; if(A[0]=A[i]) break;//满足“根”左、右，end for  else{ A[k]=A[i];//将A[i]调整到双亲结点上  k=i; } }//for  A[k]=A[0];//已找到应该插入的位置 }   2.大根堆排序 算法思想 利用大根堆 根≥左，右 的特性，\nStep1 交换堆顶与堆底元素\nStep2 去掉堆底元素，len-1，重新调整为大根堆结构（HeadAjust）\nLoop step1 , step2.\n代码实现 1 2 3 4 5 6 7 8 9 10 11  void BuildMaxHeap(int A[],int len); void HeadAdjust(int A[],int k,int len); void swap(int \u0026a,int \u0026b); void HeapSort(int A[],int n){ BuildMaxHeap(A,n);//初始建立大根堆  for (int i = n; i  1; --i) { //n-1趟交换与建堆  swap(A[i],A[1]);//堆底与堆顶元素互换  HeadAdjust(A,i,i-1);//剩余待排序元素整理成堆  } }    基于大根堆数据结构，经过排序后得到 升序序列 基于小根堆数据结构，经过排序后则会得到 降序序列\n 3.效率分析 对于BuildMaxHeap(A,n)\n不难得出，对于一个结点，每\"下坠\"一层，最多只需对比关键字2次(子树之间对比，根与子树中较大的对比)\n若树高为h，某结点在第i层，则将这个结点向下调整最多只需要\"下坠\"h-i层，关键字对比次数不超过2(h-i)\n而n个结点的完全二叉树树高$h=\\left \\lfloor \\log_2n \\right \\rfloor+1$\n第 i 层最多有$2^{i-1}$个结点，而只有第1~（h-1）层的结点才有可能需要“下坠”调整\n故将整棵树调整为大根堆，关键字对比次数不超过\n$\\sum_{i=h-1}^{1} 2^{i-1} 2(h-i)=\\sum_{i=h-1}^{1} 2^{i}(h-i)=\\sum_{j=1}^{h-1} 2^{h-j} j \\leq 2 n \\sum_{j=1}^{h-1} \\frac{j}{2^{j}} \\leq 4 n$\n建堆的过程,关键字对比次数不超过4n，建堆时间复杂度=O(n)\n对于n-1趟交换与建堆\n根节点最多“下坠” h-1 层，\n⽽每“下坠”⼀层，最多只需对⽐关键字2次，\n因此每⼀趟排序复杂度不超过 $O(h) = O(log_2n)$ 共n-1 趟，\n总的时间复杂度 = $O(nlog_2n)$\n因此，\n堆排序时间复杂度=$O(n) + O(nlog_2n)=O(nlog_2n)$ \n4.堆的插入与删除 4.1 插入 对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路\"上升\"，直到无法继续上升为止。\n4.2 删除 被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止\n归并排序 1.算法思想 对于一个给定的序列\n第一趟，将每1个元素看做一个组，相邻的两组进行二路归并\n第二趟，将每相邻的2个有序元素序列看做一组，相邻的两组进行二路归并\n第三趟，将每相邻的4个有序元素序列看做一组，相邻的两组进行二路归并\n….\n直至所有元素都有序\n2.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  int *B=(int *)malloc(n*sizeof(int));//辅助数组，长度等于A数组  //A[low...mid]和A[mid+1...high]各自有序，将两个部分归并 void Merge(int A[],int low,int mid,int high) { int i,j,k; for (k = low; k  high; k++) //将A[low...high]复制到B  B[k]=A[k]; for (i = low,j=mid+1,k=i; i  mid\u0026\u0026jk; k++) {//归并  if (B[i]B[j]) //较小者复制到A中  A[k]=B[i++]; else A[k]=B[j++]; }//for  while (imid) A[k++]=B[i++]; while (jhigh) A[k++]=B[j++]; } void MergeSort(int A[],int low,int high) { if (lowhigh) { int mid=(low+high)/2;//从中间划分  MergeSort(A,low,mid);//左部分归并  MergeSort(A,mid+1,high);//右部分归并  Merge(A,low,mid,high);//两部分归并  } }    关于merge方法可以对照下图理解\n 基数排序 基数算法不是基于“比较”的排序算法\n1.算法思想 （具体的例子）\n对于一个元素最高位为3位数的序列，将不足3位的元素前面补0.\n第一趟 按“个位“分配、收集：得到按“个位”递减排序的序列\n第二趟按“十位分配、收集：得到按“十位”递减排序的序列，“十位相同的按“个位递减排序\n第三趙按“百位”分配、收集：得到一个按“百位递减排列的序列，若“百位”相同则按“十位递减排列，若“十位还相同则按“个位递减排列。\n定义如下\n2.效率分析 2.1 空间 需要 r 个辅助队列，空间复杂度 = O(r)\n2.2 时间 ⼀趟分配O(n)，⼀趟收集O(r)，总共 d 趟分配、收集，总的时间复杂度=$O(d(n+r))$\n2.3稳定性 3.拓展应用 应用方向\n①数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩\n②每组关键字的取值范围不⼤，即 r 较⼩\n③数据元素个数 n 较⼤\n",
  "wordCount" : "762",
  "inLanguage": "en",
  "datePublished": "2021-06-10T00:00:00Z",
  "dateModified": "2021-06-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Archai"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Archai's home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.fintinger.site/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id=" top">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
        document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.fintinger.site" accesskey="h" title="🛖Home (Alt + H)">🛖Home</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.fintinger.site/posts/" title="Posts📑">
                    <span>Posts📑</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/categories/" title="Categories🛒">
                    <span>Categories🛒</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/search/" title="Search🔎 (Alt &#43; /)" accesskey=/>
                    <span>Search🔎</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/archives/" title="Timeline🕰️">
                    <span>Timeline🕰️</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/about/" title="About🥳">
                    <span>About🥳</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.fintinger.site">Home</a>&nbsp;»&nbsp;<a href="https://www.fintinger.site/posts/">Posts</a></div>
    <h1 class="post-title">
      排序算法相关
    </h1>
    <div class="post-meta"><span title='2021-06-10 00:00:00 +0000 UTC'>June 10, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Archai

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5" aria-label="相关概念">相关概念</a><ul>
                        
                <li>
                    <a href="#1%e8%af%84%e4%bb%b7%e6%8c%87%e6%a0%87" aria-label="1.评价指标">1.评价指标</a></li>
                <li>
                    <a href="#2%e5%88%86%e7%b1%bb" aria-label="2.分类">2.分类</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" aria-label="插入排序">插入排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="2.代码实现">2.代码实现</a></li>
                <li>
                    <a href="#3%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af" aria-label="3.优化思路">3.优化思路</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f" aria-label="希尔排序">希尔排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-1" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="2.代码实现">2.代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" aria-label="冒泡排序">冒泡排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-2" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2" aria-label="2.代码实现">2.代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f" aria-label="快速排序">快速排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-3" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3" aria-label="2.代码实现">2.代码实现</a></li>
                <li>
                    <a href="#3%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af-1" aria-label="3.优化思路">3.优化思路</a></li>
                <li>
                    <a href="#4%e6%b3%a8%e6%84%8f" aria-label="4.注意">4.注意</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" aria-label="简单选择排序">简单选择排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-4" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4" aria-label="2.代码实现">2.代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a0%86%e6%8e%92%e5%ba%8f" aria-label="堆排序☆">堆排序☆</a><ul>
                        
                <li>
                    <a href="#1%e5%bb%ba%e7%ab%8b%e5%a4%a7%e6%a0%b9%e5%a0%86" aria-label="1.建立大根堆">1.建立大根堆</a><ul>
                        
                <li>
                    <a href="#%e6%80%9d%e8%b7%af" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#2%e5%a4%a7%e6%a0%b9%e5%a0%86%e6%8e%92%e5%ba%8f" aria-label="2.大根堆排序">2.大根堆排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3" aria-label="算法思想">算法思想</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="代码实现">代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#3%e6%95%88%e7%8e%87%e5%88%86%e6%9e%90" aria-label="3.效率分析">3.效率分析</a></li>
                <li>
                    <a href="#4%e5%a0%86%e7%9a%84%e6%8f%92%e5%85%a5%e4%b8%8e%e5%88%a0%e9%99%a4" aria-label="4.堆的插入与删除">4.堆的插入与删除</a><ul>
                        
                <li>
                    <a href="#41-%e6%8f%92%e5%85%a5" aria-label="4.1 插入">4.1 插入</a></li>
                <li>
                    <a href="#42-%e5%88%a0%e9%99%a4" aria-label="4.2 删除">4.2 删除</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f" aria-label="归并排序">归并排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-5" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5" aria-label="2.代码实现">2.代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f" aria-label="基数排序">基数排序</a><ul>
                        
                <li>
                    <a href="#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-6" aria-label="1.算法思想">1.算法思想</a></li>
                <li>
                    <a href="#2%e6%95%88%e7%8e%87%e5%88%86%e6%9e%90" aria-label="2.效率分析">2.效率分析</a><ul>
                        
                <li>
                    <a href="#21-%e7%a9%ba%e9%97%b4" aria-label="2.1 空间">2.1 空间</a></li>
                <li>
                    <a href="#22-%e6%97%b6%e9%97%b4" aria-label="2.2 时间">2.2 时间</a></li>
                <li>
                    <a href="#23%e7%a8%b3%e5%ae%9a%e6%80%a7" aria-label="2.3稳定性">2.3稳定性</a></li></ul>
                </li>
                <li>
                    <a href="#3%e6%8b%93%e5%b1%95%e5%ba%94%e7%94%a8" aria-label="3.拓展应用">3.拓展应用</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>适用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>稳定</td>
<td>n较小，初始序列基本有序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n^{1.3})$</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>稳定</td>
<td>n较小，初始序列基本有序</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(nlog_2n)$</td>
<td>不稳定</td>
<td>初始序列无序</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>不稳定</td>
<td>n较小</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\log_2n)$</td>
<td>O(1)</td>
<td>不稳定</td>
<td>n较大或只排前几位</td>
</tr>
<tr>
<td>2-路归并排序</td>
<td>$O(n\log_2n)$</td>
<td>O(n)</td>
<td>稳定</td>
<td>n很大</td>
</tr>
<tr>
<td>链式基数排序</td>
<td>$O(d(n+rd))$</td>
<td>$O(rd)$</td>
<td>稳定</td>
<td>n大，关键字值小</td>
</tr>
</tbody>
</table>
<!-- more -->
<h2 id="相关概念">相关概念<a hidden class="anchor" aria-hidden="true" href="#相关概念">#</a></h2>
<h3 id="1评价指标">1.评价指标<a hidden class="anchor" aria-hidden="true" href="#1评价指标">#</a></h3>
<p>时间复杂度，空间复杂度，算法的<strong>稳定性</strong></p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606155832.png" alt=""  />
</p>
<h3 id="2分类">2.分类<a hidden class="anchor" aria-hidden="true" href="#2分类">#</a></h3>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606155837.png" alt=""  />
</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610164946.png" alt=""  />
</p>
<h2 id="插入排序">插入排序<a hidden class="anchor" aria-hidden="true" href="#插入排序">#</a></h2>
<h3 id="1算法思想">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想">#</a></h3>
<p>每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成。</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115037.gif" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//递增排序
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//长度为n的int型数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i,j,temp;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">&lt;</span> A[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) {<span style="color:#75715e">//如果A[i]的小于其前驱则进行A[i]的移动
</span><span style="color:#75715e"></span>            temp<span style="color:#f92672">=</span>A[i];<span style="color:#75715e">//临时保存A[i]
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> A[j]<span style="color:#f92672">&gt;</span>temp; j<span style="color:#f92672">--</span>)<span style="color:#75715e">//依次检查A[i]之前已经排好序的元素
</span><span style="color:#75715e"></span>                A[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>A[j];<span style="color:#75715e">//大于temp的后移
</span><span style="color:#75715e"></span>            A[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>temp;<span style="color:#75715e">//最终复制到插入位置
</span><span style="color:#75715e"></span>        }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="3优化思路">3.优化思路<a hidden class="anchor" aria-hidden="true" href="#3优化思路">#</a></h3>
<p><strong>折半插入排序</strong>——先用折半查找找到应该插入的位置，再进行移动元素。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){
    <span style="color:#66d9ef">int</span> i,j,low,high,mid;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        A[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>A[i];
        low<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,high<span style="color:#f92672">=</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//折半查找的范围
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (low<span style="color:#f92672">&lt;=</span>high) {
            mid<span style="color:#f92672">=</span>(low<span style="color:#f92672">+</span>high)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span> (A[mid<span style="color:#f92672">&gt;</span>A[<span style="color:#ae81ff">0</span>]]) high<span style="color:#f92672">=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//查找左部分
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> low<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//查找右部分
</span><span style="color:#75715e"></span>        }
        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&gt;=</span>high<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">--</span>)<span style="color:#75715e">//i之前元素全部后移
</span><span style="color:#75715e"></span>            A[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>A[j];
        A[high<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>A[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>    }
}
</code></pre></td></tr></table>
</div>
</div><p><strong>注意：</strong>  一直到low&gt;high时才停止折半查找当mid所指元素等于当前元素时，应继续令low=mid+1，以保证<u>“稳定性“</u>。最终应将当前元素插入到low所指位置（即high+1）</p>
<h2 id="希尔排序">希尔排序<a hidden class="anchor" aria-hidden="true" href="#希尔排序">#</a></h2>
<h3 id="1算法思想-1">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-1">#</a></h3>
<p>先将待排序表分割成若干形如 {i,i+d,i+2d, &hellip; , i+kd} 的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d(建议缩小一半)，重复上述过程，直到d=1为止。</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115346.png" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现-1">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现-1">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShellSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){
    <span style="color:#66d9ef">int</span> i,j,d;
    <span style="color:#66d9ef">for</span> (d <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; d <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; d<span style="color:#f92672">=</span>d<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#75715e">//步长不断衰减
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) <span style="color:#75715e">//遍历各步长为d的子表,从子表第二个元素开始处理即可
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(A[i]<span style="color:#f92672">&lt;</span>A[i<span style="color:#f92672">-</span>d]){<span style="color:#75715e">//如果发现逆序
</span><span style="color:#75715e"></span>                A[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>A[i];<span style="color:#75715e">//暂存需要交换位置的A[i]
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> ( j <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span>d; j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> A[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;</span>A[j]; j<span style="color:#f92672">-=</span>d) <span style="color:#75715e">//当子表中存在元素，判断与A[i]大小，寻找A[i]插入位置
</span><span style="color:#75715e"></span>                    A[j<span style="color:#f92672">+</span>d]<span style="color:#f92672">=</span>A[j];<span style="color:#75715e">//子表记录后移
</span><span style="color:#75715e"></span>                A[j<span style="color:#f92672">+</span>d]<span style="color:#f92672">=</span>A[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>            }<span style="color:#75715e">//if
</span><span style="color:#75715e"></span>}
</code></pre></td></tr></table>
</div>
</div><h2 id="冒泡排序">冒泡排序<a hidden class="anchor" aria-hidden="true" href="#冒泡排序">#</a></h2>
<h3 id="1算法思想-2">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-2">#</a></h3>
<p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到整个序列比较完毕。</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610114840.gif" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现-2">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现-2">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b){
    <span style="color:#66d9ef">int</span> temp<span style="color:#f92672">=</span>a;
    a<span style="color:#f92672">=</span>b;
    b<span style="color:#f92672">=</span>temp;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BubbleSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){ <span style="color:#75715e">//i之前的所有元素必然已经有序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">bool</span> flag<span style="color:#f92672">=</span>false;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span> i; j<span style="color:#f92672">--</span>) <span style="color:#75715e">//从后往前的一趟冒泡
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (A[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> A[j]) {<span style="color:#75715e">//逆序,(相等不会交换，是稳定的)
</span><span style="color:#75715e"></span>                swap(A[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],A[j]);
                flag<span style="color:#f92672">=</span>true;
            }<span style="color:#75715e">//if
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>flag) {
            <span style="color:#66d9ef">return</span>;<span style="color:#75715e">//本趟遍历flag未改变，说明已经有序,可能会提前结束
</span><span style="color:#75715e"></span>        }
    }<span style="color:#75715e">//for
</span><span style="color:#75715e"></span>}
</code></pre></td></tr></table>
</div>
</div><h2 id="快速排序">快速排序<a hidden class="anchor" aria-hidden="true" href="#快速排序">#</a></h2>
<h3 id="1算法思想-3">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-3">#</a></h3>
<p>在待排序表L[1&hellip;n]中<span style="background:#fff006">任取一个元素 pivot作为枢轴</span>（或基准，通常取首元素），通过一趟排序将待排序表<span style="background:#fff006">划分为独立的两部分</span>L[1&hellip;k-1]和L[k+1&hellip;n]使得L[1&hellip;k-1]中的所有元素小于pivot，L[k+1&hellip;n]中的所有元素大于等于pivot，则 pivot放在了其最终位置L[k]上这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115122.gif" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现-3">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现-3">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> high) {<span style="color:#75715e">//快速排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (low<span style="color:#f92672">&lt;</span>high) {<span style="color:#75715e">//递归跳出的条件
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pivotpos<span style="color:#f92672">=</span>Partition(A,low,high);<span style="color:#75715e">//进行“划分”
</span><span style="color:#75715e"></span>        QuickSort(A,low,pivotpos<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//处理左子表
</span><span style="color:#75715e"></span>        QuickSort(A,pivotpos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,high);<span style="color:#75715e">//处理右子表
</span><span style="color:#75715e"></span>    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Partition</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> high){<span style="color:#75715e">//&#34;划分&#34;函数，返回 枢轴 位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> pivot<span style="color:#f92672">=</span>A[low];<span style="color:#75715e">//取low作为枢轴
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (low<span style="color:#f92672">&lt;</span>high) {<span style="color:#75715e">//用low,high搜寻枢轴位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (low<span style="color:#f92672">&lt;</span>high <span style="color:#f92672">&amp;&amp;</span> A[high]<span style="color:#f92672">&gt;</span>pivot) high<span style="color:#f92672">--</span>;
        A[low]<span style="color:#f92672">=</span>A[high];<span style="color:#75715e">//比枢轴小的元素移动到左端
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (low<span style="color:#f92672">&lt;</span>high <span style="color:#f92672">&amp;&amp;</span> A[low]<span style="color:#f92672">&lt;</span>pivot) low<span style="color:#f92672">++</span>;
        A[high]<span style="color:#f92672">=</span>A[low];<span style="color:#75715e">//比枢轴大的元素移动到右端
</span><span style="color:#75715e"></span>    }
    A[low]<span style="color:#f92672">=</span>pivot;<span style="color:#75715e">//改变枢轴low位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> low;
}
</code></pre></td></tr></table>
</div>
</div><h3 id="3优化思路-1">3.优化思路<a hidden class="anchor" aria-hidden="true" href="#3优化思路-1">#</a></h3>
<p>枢轴的选择会直接影响快速排序算法的效率，因此<span style="color:#e01">优化应该从枢轴的选择角度考虑</span>。</p>
<p>① 选择首、中、尾三个位置的元素，取其中中间值作为枢轴元素。</p>
<p>② 随机选一个作为枢轴……</p>
<h3 id="4注意">4.注意<a hidden class="anchor" aria-hidden="true" href="#4注意">#</a></h3>
<blockquote>
<p>“一次划分” 与 “一趟排序”</p>
<ul>
<li>一次划分可以确定一个元素的最终位置</li>
<li>一趟排序也许可以确定多个元素的最终位置</li>
</ul>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210607102653.png" alt=""  />
</p>
</blockquote>
<h2 id="简单选择排序">简单选择排序<a hidden class="anchor" aria-hidden="true" href="#简单选择排序">#</a></h2>
<h3 id="1算法思想-4">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-4">#</a></h3>
<p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115005.gif" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现-4">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现-4">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b){
    <span style="color:#66d9ef">int</span> temp<span style="color:#f92672">=</span>a;
    a<span style="color:#f92672">=</span>b;
    b<span style="color:#f92672">=</span>temp;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SelectSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {<span style="color:#75715e">//从头开始遍历，最后一个元素无需处理(最终一定是最大)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> min<span style="color:#f92672">=</span>i;<span style="color:#75715e">//初始最小元素位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) <span style="color:#75715e">//在i之后所有元素中寻找最小元素位置
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (A[j]<span style="color:#f92672">&lt;</span>A[min]) min<span style="color:#f92672">=</span>j;<span style="color:#75715e">//更新最小元素位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (min<span style="color:#f92672">!=</span>i) swap(A[min],A[i]);<span style="color:#75715e">//将最小元素置于表头
</span><span style="color:#75715e"></span>    }
}
</code></pre></td></tr></table>
</div>
</div><h2 id="堆排序">堆排序☆<a hidden class="anchor" aria-hidden="true" href="#堆排序">#</a></h2>
<p>堆这种数据结构可以类比完全二叉树二叉树结构的顺序存储</p>
<p><img loading="lazy" src="https://img-blog.csdnimg.cn/2021050722150754.gif#pic_center" alt=""  />
</p>
<h3 id="1建立大根堆">1.建立大根堆<a hidden class="anchor" aria-hidden="true" href="#1建立大根堆">#</a></h3>
<p><span style="border:2px dashed #e01;padding:3px 5px">核心特性：  根≥左，右</span></p>
<h4 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h4>
<p>把所有<span style="background:#fff006">非终端结点($i \leq \left \lfloor n/2 \right \rfloor$)</span>都检查一遍，是否满足大根堆的要求。</p>
<p>检查当前结点是否满足 根≥左、右，若不满足，将<span style="color:#e01">当前结点与更大的一个孩子</span>互换。</p>
<p>若<u>元素互换破坏了下一级的堆</u>，则采用相同的方法继续往下调整（小元素不断“下坠”）</p>
<h4 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BuildMaxHeap</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> len){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)<span style="color:#75715e">//从编号最大非终端节点开始 
</span><span style="color:#75715e"></span>        HeadAdjust(A,i,len);
}

<span style="color:#75715e">//调整以k为根节点的树为大根堆
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeadAdjust</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> k,<span style="color:#66d9ef">int</span> len){
    A[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>A[k];
    <span style="color:#75715e">//寻找A[k]应该插入的位置--“下坠”
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>k; i <span style="color:#f92672">&lt;=</span> len; i<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">&lt;</span>len<span style="color:#f92672">&amp;&amp;</span>A[i]<span style="color:#f92672">&lt;</span>A[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#75715e">//找到key更大的子结点的下标
</span><span style="color:#75715e"></span>            i<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span>(A[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&gt;=</span>A[i]) <span style="color:#66d9ef">break</span>;<span style="color:#75715e">//满足“根”&gt;左、右，end for
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>{
            A[k]<span style="color:#f92672">=</span>A[i];<span style="color:#75715e">//将A[i]调整到双亲结点上
</span><span style="color:#75715e"></span>            k<span style="color:#f92672">=</span>i;
        }
    }<span style="color:#75715e">//for
</span><span style="color:#75715e"></span>    A[k]<span style="color:#f92672">=</span>A[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//已找到应该插入的位置
</span><span style="color:#75715e"></span>}
</code></pre></td></tr></table>
</div>
</div><h3 id="2大根堆排序">2.大根堆排序<a hidden class="anchor" aria-hidden="true" href="#2大根堆排序">#</a></h3>
<h4 id="算法思想">算法思想<a hidden class="anchor" aria-hidden="true" href="#算法思想">#</a></h4>
<p>利用大根堆 <u>根≥左，右</u> 的特性，</p>
<p>Step1 交换堆顶与堆底元素</p>
<p>Step2 去掉堆底元素，len-1，重新调整为大根堆结构（HeadAjust）</p>
<p>Loop step1 , step2.</p>
<h4 id="代码实现-1">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-1">#</a></h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BuildMaxHeap</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> len);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeadAdjust</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> k,<span style="color:#66d9ef">int</span> len);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){
    BuildMaxHeap(A,n);<span style="color:#75715e">//初始建立大根堆
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>i) { <span style="color:#75715e">//n-1趟交换与建堆
</span><span style="color:#75715e"></span>        swap(A[i],A[<span style="color:#ae81ff">1</span>]);<span style="color:#75715e">//堆底与堆顶元素互换
</span><span style="color:#75715e"></span>        HeadAdjust(A,i,i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//剩余待排序元素整理成堆
</span><span style="color:#75715e"></span>    }
}
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>基于大根堆数据结构，经过排序后得到 升序序列
基于小根堆数据结构，经过排序后则会得到 降序序列</p>
</blockquote>
<h3 id="3效率分析">3.效率分析<a hidden class="anchor" aria-hidden="true" href="#3效率分析">#</a></h3>
<p><span style="border-bottom:3px solid #67b440">对于<code>BuildMaxHeap(A,n)</code></span></p>
<p>不难得出，对于一个结点，每&quot;下坠&quot;一层，最多只需对比关键字<em>2</em>次(子树之间对比，根与子树中较大的对比)</p>
<p>若树高为h，某结点在第i层，则将这个结点向下调整最多只需要&quot;下坠&quot;<em>h-i</em>层，关键字对比次数不超过<em>2(h-i)</em></p>
<p>而<em>n</em>个结点的完全二叉树树高$h=\left \lfloor \log_2n \right \rfloor+1$</p>
<p>第 i 层最多有$2^{i-1}$个结点，而只有第1~（h-1）层的结点才有可能需要“下坠”调整</p>
<p>故将整棵树调整为大根堆，关键字对比次数不超过</p>
<p>$\sum_{i=h-1}^{1} 2^{i-1} 2(h-i)=\sum_{i=h-1}^{1} 2^{i}(h-i)=\sum_{j=1}^{h-1} 2^{h-j} j \leq 2 n \sum_{j=1}^{h-1} \frac{j}{2^{j}} \leq 4 n$</p>
<p><span style="color:#e01">建堆的过程,关键字对比次数不超过4n，建堆时间复杂度=O(n)</span></p>
<p><span style="border-bottom:3px solid #67b440">对于n-1趟交换与建堆</span></p>
<p>根节点最多“下坠” h-1 层，</p>
<p>⽽每“下坠”⼀层，最多只需对⽐关键字2次，</p>
<p>因此每⼀趟排序复杂度不超过 $O(h) = O(log_2n)$ 共n-1 趟，</p>
<p>总的时间复杂度 = $O(nlog_2n)$</p>
<p>因此，</p>
<p><span style="border:2px dashed #e01;padding:3px 5px">堆排序时间复杂度=$O(n) + O(nlog_2n)=O(nlog_2n)$ </span></p>
<h3 id="4堆的插入与删除">4.堆的插入与删除<a hidden class="anchor" aria-hidden="true" href="#4堆的插入与删除">#</a></h3>
<h4 id="41-插入">4.1 插入<a hidden class="anchor" aria-hidden="true" href="#41-插入">#</a></h4>
<p>对于小根堆，新元素放到<u>表尾</u>，与父节点对比，若<u>新元素比父节点更小，则将二者互换</u>。新元素就这样一路&quot;上升&quot;，<u>直到无法继续上升为止</u>。</p>
<h4 id="42-删除">4.2 删除<a hidden class="anchor" aria-hidden="true" href="#42-删除">#</a></h4>
<p><span style="color:#e01">被删除的元素用堆底元素替代</span>，然后让该元素不断“下坠”，直到无法下坠为止</p>
<h2 id="归并排序">归并排序<a hidden class="anchor" aria-hidden="true" href="#归并排序">#</a></h2>
<h3 id="1算法思想-5">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-5">#</a></h3>
<p>对于一个给定的序列</p>
<p>第一趟，将每1个元素看做一个组，相邻的两组进行二路归并</p>
<p>第二趟，将每相邻的2个有序元素序列看做一组，相邻的两组进行二路归并</p>
<p>第三趟，将每相邻的4个有序元素序列看做一组，相邻的两组进行二路归并</p>
<p>&hellip;.</p>
<p>直至所有元素都有序</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115158.gif" alt="图片来自CSDN@非晚非晚"  />
</p>
<h3 id="2代码实现-5">2.代码实现<a hidden class="anchor" aria-hidden="true" href="#2代码实现-5">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>B<span style="color:#f92672">=</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)malloc(n<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));<span style="color:#75715e">//辅助数组，长度等于A数组
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Merge</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> mid,<span style="color:#66d9ef">int</span> high) {
    <span style="color:#66d9ef">int</span> i,j,k;
    <span style="color:#66d9ef">for</span> (k <span style="color:#f92672">=</span> low; k <span style="color:#f92672">&lt;=</span> high; k<span style="color:#f92672">++</span>) <span style="color:#75715e">//将A[low...high]复制到B
</span><span style="color:#75715e"></span>        B[k]<span style="color:#f92672">=</span>A[k];
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> low,j<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,k<span style="color:#f92672">=</span>i; i <span style="color:#f92672">&lt;=</span> mid<span style="color:#f92672">&amp;&amp;</span>j<span style="color:#f92672">&lt;=</span>k; k<span style="color:#f92672">++</span>) {<span style="color:#75715e">//归并
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (B[i]<span style="color:#f92672">&lt;=</span>B[j]) <span style="color:#75715e">//较小者复制到A中
</span><span style="color:#75715e"></span>            A[k]<span style="color:#f92672">=</span>B[i<span style="color:#f92672">++</span>];
        <span style="color:#66d9ef">else</span> A[k]<span style="color:#f92672">=</span>B[j<span style="color:#f92672">++</span>];
    }<span style="color:#75715e">//for
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (i<span style="color:#f92672">&lt;=</span>mid) A[k<span style="color:#f92672">++</span>]<span style="color:#f92672">=</span>B[i<span style="color:#f92672">++</span>];
    <span style="color:#66d9ef">while</span> (j<span style="color:#f92672">&lt;=</span>high) A[k<span style="color:#f92672">++</span>]<span style="color:#f92672">=</span>B[j<span style="color:#f92672">++</span>];
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> high) {
    <span style="color:#66d9ef">if</span> (low<span style="color:#f92672">&lt;</span>high) {
        <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>(low<span style="color:#f92672">+</span>high)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//从中间划分
</span><span style="color:#75715e"></span>        MergeSort(A,low,mid);<span style="color:#75715e">//左部分归并
</span><span style="color:#75715e"></span>        MergeSort(A,mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,high);<span style="color:#75715e">//右部分归并
</span><span style="color:#75715e"></span>        Merge(A,low,mid,high);<span style="color:#75715e">//两部分归并
</span><span style="color:#75715e"></span>    }
}
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>关于<code>merge</code>方法可以对照下图理解</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609083921.png" alt=""  />
</p>
</blockquote>
<h2 id="基数排序">基数排序<a hidden class="anchor" aria-hidden="true" href="#基数排序">#</a></h2>
<p><span style="border:2px dashed #e01;padding:3px 5px">基数算法不是基于“比较”的排序算法</span></p>
<h3 id="1算法思想-6">1.算法思想<a hidden class="anchor" aria-hidden="true" href="#1算法思想-6">#</a></h3>
<p>（具体的例子）</p>
<p>对于一个元素最高位为3位数的序列，将不足3位的元素前面补0.</p>
<p>第一趟 按“个位“<u>分配、收集</u>：得到按“个位”递减排序的序列</p>
<p>第二趟按“十位分配、收集：得到按“十位”递减排序的序列，“十位相同的按“个位递减排序</p>
<p>第三趙按“百位”分配、收集：得到一个按“百位递减排列的序列，若“百位”相同则按“十位递减排列，若“十位还相同则按“个位递减排列。</p>
<p><strong>定义如下</strong></p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609101720.png" alt="image-20210609101712975"  />
</p>
<h3 id="2效率分析">2.效率分析<a hidden class="anchor" aria-hidden="true" href="#2效率分析">#</a></h3>
<h4 id="21-空间">2.1 空间<a hidden class="anchor" aria-hidden="true" href="#21-空间">#</a></h4>
<p>需要 r 个辅助队列，空间复杂度 = O(r)</p>
<h4 id="22-时间">2.2 时间<a hidden class="anchor" aria-hidden="true" href="#22-时间">#</a></h4>
<p>⼀趟分配O(n)，⼀趟收集O(r)，总共 d 趟分配、收集，总的时间复杂度=$O(d(n+r))$</p>
<h4 id="23稳定性">2.3稳定性<a hidden class="anchor" aria-hidden="true" href="#23稳定性">#</a></h4>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609103004.png" alt=""  />
</p>
<h3 id="3拓展应用">3.拓展应用<a hidden class="anchor" aria-hidden="true" href="#3拓展应用">#</a></h3>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609103234.png" alt=""  />
</p>
<p><span style="border-bottom:3px solid #67b440">应用方向</span></p>
<p>①数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩</p>
<p>②每组关键字的取值范围不⼤，即 r 较⼩</p>
<p>③数据元素个数 n 较⼤</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.fintinger.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
      <li><a href="https://www.fintinger.site/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">选择排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">计数排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">希尔排序</a></li>
      <li><a href="https://www.fintinger.site/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.fintinger.site/p/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/">
    <span class="title">« Prev Page</span>
    <br>
    <span>外部排序相关</span>
  </a>
  <a class="next" href="https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">
    <span class="title">Next Page »</span>
    <br>
    <span>查找算法相关</span>
  </a>
</nav>

  </footer><script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"avatar":"robohash","dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"],"highlight":true,"locale":{"admin":"Admin"},"placeholder":"说点什么༼ つ ◕_◕ ༽つ","requiredMeta":["name","email","url"],"serverURL":"https://waline-q3l7of5hj-fintinger.vercel.app/","visitor":true});
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://www.fintinger.site">Archai&#39;s home</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>
    if (window.screen.width <= 640 && window.location.pathname == "/") {
        document.querySelector(".profile_inner").style.opacity = 1;
    }
</script>

<script>
    if (window.location.pathname != "/" && window.screen.width > 640) {
        randomLine();
    }
    document.body.addEventListener("dblclick", _ => {
        document.querySelector("canvas").remove();
        randomLine();
    })

    function randomLine() {
        function n(n, e, t) {
            return n.getAttribute(e) || t
        }
        function e(n) {
            return document.getElementsByTagName(n)
        }
        function t() {
            var t = e("script"), o = t.length, i = t[o - 1];
            return { l: o, z: n(i, "zIndex", -88), o: n(i, "opacity", ro()), c: n(i, "color", rc()), n: n(i, "count", 300) }
        }
        
        function r() {
            return Math.floor(Math.random() * 255);
        }
        function rc() {
            return `${r()},${r()},${r()}`
        }
        function ro() {
            return (Math.floor((Math.random() * 4 + 5))) / 10
        }
        
        function o() {
            a = m.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
                c = m.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        }
        function i() {
            r.clearRect(0, 0, a, c);
            var n, e, t, o, m, l;
            s.forEach(function (i, x) {
                for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 : 1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1, 1), e = x + 1; e < u.length; e++)n = u[e],
                    null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y,
                        l = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o, i.y -= .03 * m),
                            t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y), r.lineTo(n.x, n.y), r.stroke()))
            }),
                x(i)
        }
        var a, c, u, m = document.createElement("canvas"),
            d = t(), l = "c_n" + d.l, r = m.getContext("2d"),
            x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
                function (n) {
                    window.setTimeout(n, 1e3 / 45)
                },
            w = Math.random, y = { x: null, y: null, max: 2e4 }; m.id = l, m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z + ";opacity:" + d.o, e("body")[0].appendChild(m), o(), window.onresize = o,
                window.onmousemove = function (n) {
                    n = n || window.event, y.x = n.clientX, y.y = n.clientY
                },
                window.onmouseout = function () {
                    y.x = null, y.y = null
                };
        for (var s = [], f = 0; d.n > f; f++) {
            var h = w() * a, g = w() * c, v = 2 * w() - 1, p = 2 * w() - 1; s.push({ x: h, y: g, xa: v, ya: p, max: 6e3 })
        }
        u = s.concat([y]),
            setTimeout(function () { i() }, 100)
    };

</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                if (id === "top") {
                document.body.scrollIntoView({
                    behavior: "smooth"
                })
                return true;
            }
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                document.body.scrollIntoView({
                    behavior: "smooth"
                })
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
window.onerror=function(){return true;}
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<video id="liveBgBox" autoplay="" loop="true" muted="" src="" style="display: none;"></video>
</body>
<script>
    
    window.onload = function () {
        vid.src = "https://jqf.oss-cn-beijing.aliyuncs.com/videos/7kgkoysahpw31.mp4"
        vid.play();
    }

    let vid = document.getElementById("liveBgBox");
    let profile = document.getElementsByClassName("profile")[0];
    if (profile) {
        vid.style.display = "block";
        window.document.body.style.background="url('https://jqf.oss-cn-beijing.aliyuncs.com/images/poster1.png') no-repeat  center/cover fixed";
    }

</script>
</html>