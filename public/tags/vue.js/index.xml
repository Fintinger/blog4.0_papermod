<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Vue.js on Archai&#39;s home</title>
    <link>https://www.fintinger.site/tags/vue.js/</link>
    <description>Recent content in Vue.js on Archai&#39;s home</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 21 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fintinger.site/tags/vue.js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue中的数据监视原理</title>
      <link>https://www.fintinger.site/p/vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.fintinger.site/p/vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86%E5%8E%9F%E7%90%86/</guid>
      <description>1.vue会监视data中所有层次的数据. vue对于配置在data中的所有对象都会以key值作为目标进行监视，不论多少层，都会递归地为每一个key配置getter和setter(通过Object.defineProperty())。
 相关阅读 MDN关于defineProperty的说明
 2.如何监测对象中的数据? 通过setter实现监视,且要在new Vue时就传入要监测的数据，即在data中提前配置。
(1).对象中后追加的属性,Vue默认不做响应式处理
直接通过修改vm._data或者vm来添加key，并不会配置getter和setter，因此不会做响应式
(2).如需给后添加的属性做响应式,请使用如下API: Vue.set(target,key/index,value)或vm.$set(target,key/index,value)（可以同时修改数组和对象）
​	特别注意: Vue.set()和vm.$set()不能直接给vm或vm的根数据对象(vm._data)添加属性!!!
3.如何监测数组中的数据? 在数组中直接通过索引的方式修改数组并不会引起Vue的响应，那么要如何做呢？Vue通过包裹数组更新元素的方法(对原数组方法进行修改)实现,本质就是做了两件事:
(1). 调用原生对应的方法对数组进行更新.
(2). 重新解析模板,进而更新页面.
就包裹了下面的七种数组方法：
 push() pop() shift() unshift() splice() sort() reverse()  也就是说，通过上面七种方法修改数组，会让Vue做出响应。
例如想要修改数组中索引为0的位置的数据，可以通过 vm.data.arr.splice(0,0,val)或Vue.set(vm.data.arr,0,val)又或者vm.$set(vm.data.arr,0,val)，在具体的由Vue管理的方法中this指向的应该就是vm！！
数据劫持 Vue通过setter,getter对数据进行动态监测，其实就是“劫持”了数据😯</description>
    </item>
    
    <item>
      <title>vue.js学习心得</title>
      <link>https://www.fintinger.site/p/vue.js%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.fintinger.site/p/vue.js%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</guid>
      <description>1. 关于元素显示与隐藏  # v-show=&amp;quot;name&amp;quot;  说明： 如果data中name为true就显示，否则该元素display:none   # v-if=&amp;quot;name&amp;quot;  说明： 如果data中name为true就显示，否则该元素变成一段注释&amp;lt;!----&amp;gt;，就被删掉了!   v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
 2. 访问data 　# v-model  说明： 与data中的值绑定，会随着data中的值得改变而改变，如果是input则data中的值会随着input中的值的改变而改变  # v-if   **说明：**用于条件性地渲染一块内容
 在&amp;lt;template&amp;gt;元素上使用 v-if 条件渲染分组
因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换(隐藏或显示)多个元素呢？此时可以把一个&amp;lt;template&amp;gt;元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含&amp;lt;template&amp;gt;元素。
这样做的好处就是不用再写一个&amp;lt;div&amp;gt;将需要隐藏的元素包裹
   # v-show  说明： 条件切换display属性  # v-for  说明： 在data中定义一个数组arr，然后用v-for=&amp;quot;val in arr&amp;quot;访问到  3.</description>
    </item>
    
  </channel>
</rss>
